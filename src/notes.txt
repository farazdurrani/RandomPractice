Object is the super most class. 
public and protected members are accessible in subclasses (all the way down).
But protected members are only accessible in the same package.
private are only accessible inside the class.

A subclass always calls superclass's constructor implicitly if super(..) is not called
A default/no args constructor is called implicitly

Constructors are not inherited. Methods are. 

If a method in a superclass is public, it cannot be made protected or private in any of the subclasses. 
If a method in a superclass is protected, it cannot be made private in any of the subclasses.

If a method or Constructor has exception thrown in signature, then client code must try/catch or delegate.
If a method or constructor does not have exception thrown in signature, then client code doesn't need to try/catch or delegate.

If you create an object of a class that extends a parent class, 
then you can call methods of a parent class on this child class directly.
But if a method is not overridden in a child class, parents method implementation will be used. 
If you create a new method in a child class, and if the object is of type Parent but it holds a child reference, 
then you can call child's method by downcasting it. 

If a method is overridden and you call that method, that method will be called. But if that method is not overridden, parent's method will be called. 

Intance methods shouldn't be called in a contructor. 

Protected instant members are available to subclasses even if subclasses are created in a different package.
But protected instant members are not available when an object of a class that contains protected members are created in a different package.

Polymorphism (extensible):
Lets say a superclass has a method that every subclass overides with distinct behaviors. 
We create an object of a subclass but assign it to a superclass variable. 
Then We invoke a common method on this superclass variable. 
Program will invoke subclass method by determining it at runtime that this superclass variable holds a reference of subclass object. 
This is polymorphism. Same method but different forms. Form is determined at runtime.

Abstract classes:

n abstract class provides a default behavior that your implementation can reuse.
https://stackoverflow.com/a/37905386/4828463


A class that you never intend to create objects of, can be abstract classes. 
These classes cannot be instantiated and must be extended because abstract classes are incomplete. 
Abstract methods do not provide implementations. 
A class that contains any abstract methods must be explicitly devclared abstract even if that class contains some concrete methods.
Each cibcrete subclass of an abstract ckass must provide concrete implementations of each of the superclass's abstract methods. 

Constructors and static methods cannot be declared abstract. Constructors are not inherited so contructors cannot be abstract.

Non private static methods are inherited, but they cannot be overridden.

If you declare a method as abstract, a class must also be declared as abstract. 
If you entend an abstract class, you must either override the abstract method or declare the extending class as abstract.

Issues with calling instance methods in a Constructor:

The subclass constructor first calls a constructor in its direct superclass. 
At this point, any subclass instance cariable initialiazation code in the subclass constructor's body has not yet executed. 
If the superclass constructor then calls a method that the subclass overrides, the subclass's version executes.

Interfaces:

Till Java 7, Interfaces could only contains constants and abstract methods. 
Interfaces must be public.
It cannot provide any method implementation details and instance variables.
All methods decalred in an interface are implicitly public. And all fields are implicitly public, static, and final.

A class can extend only one class, but it can implement multiple interfaces

But in Java 8, default method implementations can be provided. And if implementing class doesn't override those methods, default methods are used.
In Java 9, private methods could also be added.

Marker Interfaces have no methods declerations and no constants. 
They are used to add a IS-A relationships to classes like how I did when writing to multiple documents using Spring Writer

Since Java 8, you can add default methods in an interface. 
If an implementing class doesn't override this method, default method implementation carries over. 
It will also not break an implementing class.
You can also have static methods in interface. You just cannot override them.

Functional Interface:
an interface that contains exactly one abstract method.


Exception:

You can throw Throwable (instead of an Exception). You can also rethrow the same exception by 'throw e'.
Don't use Error. Throwable is extended by 2 classes -> Error and Exception.
Error shouldn't be used by developers. It is mostly used by jvm.
Developers should use Exception or any of the classes that extend Exception in exception-handling mechanism. 

Unchecked Exception:

RuntimeException and any of its subclasses are unchecked exception.
Error and any of it's subclasses are also unchecked exceptions. These are unrecoverable exceptions and developers should avoid from handing them.
Usually, unchecked exceptions are not wrapped around try statement. Even though you can if you want to.

Checked Exception:
Any exception that inherits from class Exception but not thru RuntimeException is checked exception.
Checked exceptions must be handled by this formula: "catch-or-declare." Otherwise, compiler complains. 

If a catch handler is writtern to catch superclass exception objects, it can also catch all objects of that class's subclasses.
This enables catch to handle related exceoptions polymorphically.

It is a compilation error to catch the exact same type in two different catch blocks associated with a particular try block.
One must use handle specific exception in a catch block, and then work towards more general exception.
Subclass exceptions first, then Superclass exceptions.
 